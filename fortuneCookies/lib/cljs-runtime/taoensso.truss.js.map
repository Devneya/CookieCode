{"version":3,"sources":["taoensso/truss.cljc"],"mappings":";;AAKA,AA2DA,AACA,AAUA,AAmEA,AAOA;;;0BAAA,1BAAMA;AAAN,AAEKC;;AAQL,AAEA,2BAAA,3BAASC,8DAAWC;AAApB,AAAuB,GAAI,+CAAA,/CAACC,6CAAED;AAAYE;;AAAsBF;;;AAChE;;;oCAAA,pCAAMG,gFAEHH;AAFH,AAGW,QAAkBI,2CAAuB,AAACL,yBAAUC;;AAS/D;;;4CAAA,5CAAMK;AAAN,AAGKP","names":["taoensso.truss/get-data","taoensso.truss.impl/*data*","taoensso.truss/-error-fn","f","cljs.core._EQ_","taoensso.truss.impl/default-error-fn","taoensso.truss/set-error-fn!","taoensso.truss.impl/*error-fn*","taoensso.truss/get-dynamic-assertion-data"],"sourcesContent":["(ns taoensso.truss\n  \"An opinionated assertions API for Clojure/Script.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n  (:require [taoensso.truss.impl :as impl :refer [-invariant]]))\n\n(comment (require '[taoensso.encore :as enc]))\n\n;;;; Core API\n\n#?(:clj\n   (defmacro have\n     \"Takes a pred and one or more vals. Tests pred against each val,\n     trapping errors. If any pred test fails, throws a detailed assertion error.\n     Otherwise returns input val/vals for convenient inline-use/binding.\n\n     Respects *assert* value so tests can be elided from production for zero\n     runtime costs.\n\n     Provides a small, simple, flexible feature subset to alternative tools like\n     clojure.spec, core.typed, prismatic/schema, etc.\n\n       ;; Will throw a detailed error message on invariant violation:\n       (fn my-fn [x] (str/trim (have string? x)))\n\n     You may attach arbitrary debug info to assertion violations like:\n       `(have string? x :data {:my-arbitrary-debug-info \\\"foo\\\"})`\n\n     Re: use of Truss assertions within other macro bodies:\n       Due to CLJ-865, call site information (e.g. line number) of\n       outer macro will unfortunately be lost.\n\n       See `keep-callsite` util for a workaround.\n\n     See also `have?`, `have!`.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(-invariant :elidable nil ~(:line (meta &form)) ~args)))\n\n#?(:clj\n   (defmacro have?\n     \"Like `have` but returns `true` on successful tests. In particular, this\n     can be handy for use with :pre/:post conditions. Compare:\n       (fn my-fn [x] {:post [(have  nil? %)]} nil) ; {:post [nil]} FAILS\n       (fn my-fn [x] {:post [(have? nil? %)]} nil) ; {:post [true]} passes as intended\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(-invariant :elidable :truthy ~(:line (meta &form)) ~args)))\n\n#?(:clj\n   (defmacro have!\n     \"Like `have` but ignores *assert* value (so can never be elided). Useful\n     for important conditions in production (e.g. security checks).\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(-invariant nil nil ~(:line (meta &form)) ~args)))\n\n#?(:clj\n   (defmacro have!?\n     \"Specialized cross between `have?` and `have!`. Not used often but can be\n     handy for semantic clarification and/or to improve multi-val performance\n     when the return vals aren't necessary.\n\n     **WARNING**: Do NOT use in :pre/:post conds since those are ALWAYS subject\n     to *assert*, directly contradicting the intention of the bang (`!`) here.\"\n     {:arglists '([x] [pred (:in) x] [pred (:in) x & more-xs])}\n     [& args] `(-invariant :assertion :truthy ~(:line (meta &form)) ~args)))\n\n(comment :see-tests)\n(comment\n  (macroexpand '(have a))\n  (macroexpand '(have? [:or nil? string?] \"hello\"))\n\n  (enc/qb 1e5\n    (with-error-fn nil                   (have? string? 5))\n    (with-error-fn (fn [_] :truss/error) (have? string? 5)))\n\n  (have string? (range 1000)))\n\n(comment\n  ;; HotSpot is great with these:\n  (enc/qb 1e4\n    (string? \"a\")\n    (have?   \"a\")\n    (have            string?  \"a\" \"b\" \"c\")\n    (have? [:or nil? string?] \"a\" \"b\" \"c\")\n    (have? [:or nil? string?] \"a\" \"b\" \"c\" :data \"foo\"))\n  ;; [     5.59 26.48 45.82     ] ; 1st gen (macro form)\n  ;; [     3.31 13.48 36.22     ] ; 2nd gen (fn form)\n  ;; [0.82 1.75  7.57 27.05     ] ; 3rd gen (lean macro form)\n  ;; [0.4  0.47  1.3  1.77  1.53] ; 4th gen (macro preds)\n\n  (enc/qb 1e4\n    (have  string? :in [\"foo\" \"bar\" \"baz\"])\n    (have? string? :in [\"foo\" \"bar\" \"baz\"]))\n\n  (macroexpand '(have string? 5))\n  (macroexpand '(have string? 5 :data \"foo\"))\n  (macroexpand '(have string? 5 :data (enc/get-env)))\n  (let [x :x]   (have string? 5 :data (enc/get-env)))\n\n  (have string? 5)\n  (have string? 5 :data {:a \"a\"})\n  (have string? 5 :data {:a (/ 5 0)})\n\n  ((fn [x]\n     (let [a \"a\" b \"b\"]\n       (have string? x :data {:env (enc/get-env)}))) 5)\n\n  (do\n    (set! *assert* false)\n    (have? integer? 4.0))\n\n  ;; Combinations: truthy?, single?, in? (8 combinations)\n  (do (def i1 1) (def v1 [1 2 3]) (def s1 #{1 2 3}))\n  (macroexpand '(have? integer?      1))\n  (macroexpand '(have? integer?      1 2 i1))\n  (macroexpand '(have? integer? :in [1 2 i1]))\n  (macroexpand '(have? integer? :in [1 2] [3 4 i1] v1))\n  (macroexpand '(have  integer?      1))\n  (macroexpand '(have  integer?      1 2 i1))\n  (macroexpand '(have  integer? :in [1 2 i1]))\n  (macroexpand '(have  integer? :in [1 2] [3 4 i1] v1))\n\n  (have? integer? :in s1)\n  (have  integer? :in s1)\n  (have  integer? :in #{1 2 3})\n  (have  integer? :in #{1 2 3} [4 5 6] #{7 8 9} s1))\n\n;;;; Utils\n\n#?(:clj\n   (defmacro keep-callsite\n     \"CLJ-865 unfortunately means that it's currently not possible\n     for an inner macro to access the &form metadata of an outer macro.\n\n     This means that inner macros lose call site information like the\n     line number of the outer macro.\n\n     This util offers a workaround to authors of the outer macro:\n       (defmacro foo1 [x]                `(truss/have ~x))  ; W/o  line info\n       (defmacro foo2 [x] (keep-callsite `(truss/have ~x))) ; With line info\"\n\n     {:added \"v1.8.0 (2022-12-13)\"}\n     [& body] `(with-meta (do ~@body) (meta ~'&form))))\n\n(comment\n  (defmacro foo1 [x]                `(have ~x))\n  (defmacro foo2 [x] (keep-callsite `(have ~x)))\n\n  (foo1 nil)\n  (foo2 nil))\n\n(defn get-data\n  \"Returns current value of dynamic assertion data.\"\n  [] impl/*data*)\n\n#?(:clj\n   (defmacro with-data\n     \"Executes body with dynamic assertion data bound to given value.\n     This data will be included in any violation errors thrown by body.\"\n     [data & body] `(binding [impl/*data* ~data] ~@body)))\n\n(comment (with-data \"foo\" (have string? 5 :data \"bar\")))\n\n(defn-   -error-fn [f] (if (= f :default) impl/default-error-fn f))\n(defn set-error-fn!\n  \"Sets the root (fn [data-map-delay]) called on invariant violations.\"\n  [f]\n  #?(:cljs (set!             impl/*error-fn*        (-error-fn f))\n     :clj  (alter-var-root #'impl/*error-fn* (fn [_] (-error-fn f)))))\n\n#?(:clj\n   (defmacro with-error-fn [f & body]\n     `(binding [impl/*error-fn* ~(-error-fn f)] ~@body)))\n\n;;;; Deprecated\n\n(defn get-dynamic-assertion-data\n  {:deprecated \"v1.7.0 (2022-11-16)\"\n   :doc \"Prefer `get-data`\"}\n  [] impl/*data*)\n\n#?(:clj\n   (defmacro with-dynamic-assertion-data\n     {:deprecated \"v1.7.0 (2022-11-16)\"\n      :doc \"Prefer `with-data`\"}\n     [data & body] `(binding [impl/*data* ~data] ~@body)))\n"],"x_google_ignoreList":[0]}