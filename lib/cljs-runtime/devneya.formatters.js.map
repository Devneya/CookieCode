{"version":3,"sources":["devneya/formatters.cljs"],"mappings":";;AAMA;;;;;;;;8CAAA,9CAAMA,oGAKFC,OAAOC,MAAMC;AALjB,AAMG,+DAAA,/DAACC,wDAAYH;;AACb,IAAMI,UAAQ,iBAAA,jBAACC,0DAAiDH;qBAAhE,jBACMI;IAUAC,SAAO,4CAAA,WAAAC,vDAACC;AAAD,AAAM,kIAAA,9EAAK,4CAAAD,5CAACE,6DAAOJ;GAAsBF;IAChDO,SAAO,iBAAAC,mBAAI,EAAI,qDAAA,rDAACC,6CAAET,eAAaF,KAAK,AAACY,+CAAOC,cAAIR;AAAzC,AAAA,oBAAAK;AAAAA;;AAAA;;;IACPD,aAAO,8BAAA,wBAAA,tDAACK,uBAAcL;AAb5B,AAcE,GAAI,mDAAA,nDAACE,6CAAEZ;AACLU;;AACA,GAAI,2BAAA,1BAAG,AAACM,gBAAMV;AACZ,wDAAA,jDAACW;;AACDP;;;;AAET,mCAAA,nCAAMQ,8EACHnB,OAAOE;AADV,AAEE,+DAAA,/DAACC,wDAAYH;;AACb,mCAAA,+BAAA,3DAACgB,uBAAcd;;AAIjB;;;sCAAA,tCAAMkB,oFAEHpB,OAAOE,KAAKmB;AAFf,AAGE,+DAAA,/DAAClB,wDAAYH;;AACb,IAAMsB,wBAAsB,mCAAA,IAAA,WAAAC,lDAACP,uBAAcK;AAAf,AAAiC,QAAA,6NAAA,5KAAU,mJAAA,MAAAE,vJAAI,EAAI,6CAAAA,iBAAA,9DAACV,yEAAW,6CAAAU,iBAAA,9DAACV;;IAEtFW,gBAAc,AAACC,qBAAW,CAAA,8CAAA,tBAA6BH;6BAF7D,zBAIMI;2BAJN,vBAMMC;AANN,AAQE,iDAAA,WAAAC,rDAACZ,uBAAcd,KAAKsB;AAApB,AAAmC,QAAA,6JAAA,tFAAgC,4CAAAI,5CAAClB,6DAAOgB,8EAAiC,4CAAAE,5CAAClB,6DAAOiB","names":["devneya.formatters/remove-triple-back-quote","log-id","merge","stri","devneya.utils.log_with_id","matched","cljs.core/re-seq","index_of_block","blocks","p1__18936#","cljs.core.map","cljs.core.get","result","or__5045__auto__","cljs.core._EQ_","cljs.core.reduce","cljs.core/str","clojure.string/replace","cljs.core/count","failjure.core.fail","devneya.formatters/remove-colors","devneya.formatters/remove-user-path","output-path","output-with-underline","p1__18947#","re-bad-string","cljs.core/re-pattern","index-of-string-number","index-of-char-number","p1__18949#"],"sourcesContent":["(ns devneya.formatters\n  (:require [failjure.core :as f]\n            [clojure.string :as clstr]\n            [devneya.utils :refer [log-with-id]])\n  (:require-macros [failjure.core]))\n\n(defn remove-triple-back-quote\n  \"Removes triple back quote\n   ```(\\\\w+)?(\\r)?\\n matches line with opening triple back quote and language name\n   ([\\\\s\\\\S]+?) matches text between quotes (if exists)\n   (\\r)?\\n``` line with closing triple back quote\"\n  ([log-id merge stri] \n   (log-with-id log-id \"remove-triple-back-quote function started\")\n   (let [matched (re-seq #\"(```(\\w+)?(\\r)?\\n([\\s\\S]*?)(\\r)?\\n```)\" stri)\n         index_of_block 4\n        ;;  Maybe \\n is not fully correct here, need to test this or if some problem occure the following code might be used\n         \n        ;;  (ns my-app.core\n        ;;    (:require [goog.userAgent.platform :as platform]))\n\n        ;;  (defn get-newline-symbol []\n        ;;    (cond\n        ;;      (= platform/WINDOWS) \"\\r\\n\"\n        ;;      :else \"\\n\"))\n         blocks (map #(str (get %1 index_of_block) \"\\n\") matched)\n         result (or (if (= matched nil) stri (reduce str blocks)) \"\")\n         result (clstr/replace result #\"(```(\\w+)?(\\r)?\\n```)\" \"\")]\n     (if (= merge 1)\n       result\n       (if (> (count blocks) 1)\n         (f/fail \"chatGPT splitted the code to multiple blocks, try to simplyfy your request\")\n         result)))))\n\n(defn remove-colors\n  [log-id stri]\n  (log-with-id log-id \"remove-colors function started\")\n  (clstr/replace stri #\"\u001b\\[([0,1,2,3,4,5,6,7,8,9]+)m\"  \"\"))\n\n;; Huge problem with / and \\, if there is a \\, we need to parse them much more carefully or we can just ban them\n;; Maybe it's better to think, that output-path is just filename and it cant contain any \\ or /\n(defn remove-user-path\n  \"In that version output path should be just a file name\"\n  [log-id stri output-path]\n  (log-with-id log-id \"remove-user-path function started\")\n  (let [output-with-underline (clstr/replace output-path #\".\" #(str \"[_\" (if (or (= %1 \"\\\\\") (= %1 \"/\")) \"\\\\/\" %1) \"]\")),\n        ;;regexp parsing: \"at 'any part of path before output-path entrance' output-path :num1:num2\"\" num1 and num2 are string and character\n        re-bad-string (re-pattern (str \"([\\\\s^]*)at ([_\\\\S]*)\" output-with-underline \"[_:]([_\\\\d]+)[_:]([_\\\\d]+)\"))\n        ;;number of group in regexp that matches number of string where error starts\n        index-of-string-number 3,\n        ;;number of group in regexp that matches position in string where error starts\n        index-of-char-number 4]\n    ;; TODO: add correct '\\r\\n' or '\\n' according to the platform  \n    (clstr/replace stri re-bad-string #(str \" Error starts at string \" (get %1 index-of-string-number) \" char \" (get %1 index-of-char-number)))))"]}